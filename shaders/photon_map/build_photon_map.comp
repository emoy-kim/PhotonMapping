#version 460

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

struct Photon
{
   vec3 Power;
   vec3 Position;
   vec3 IncomingDirection;
};

struct AreaLight
{
   float Area;
   vec3 Emission;
   vec3 Normal;
   vec3 Vertex0;
   vec3 Vertex1;
   vec3 Vertex2;
};

struct Rect
{
   vec3 MinPoint;
   vec3 MaxPoint;
};

layout (binding = 0, std430) buffer Photons { Photon photons[]; };
layout (binding = 1, std430) buffer Lights { AreaLight lights[]; };
layout (binding = 2, std430) buffer WorldBounds { Rect world_bounds[]; };
layout (binding = 3, std430) buffer Vertices { float vertices[]; };
layout (binding = 4, std430) buffer Normals { float normals[]; };
layout (binding = 5, std430) buffer Indices { uint indices[]; };
layout (binding = 6, std430) buffer VertexSizes { int vertex_sizes[]; };
layout (binding = 7, std430) buffer IndexSizes { int index_sizes[]; };

layout (location = 0) uniform uint Seed;
layout (location = 1) uniform int MaxGlobalPhotonNum;
layout (location = 2) uniform int MaxDepth;
layout (location = 3) uniform int ObjectNum;

#define MAX_OBJECT_NUM 10
layout (location = 4) uniform vec3 ObjectBRDFs[MAX_OBJECT_NUM];
layout (location = 14) uniform int ObjectMaterialTypes[MAX_OBJECT_NUM]; // 0: Lambert, 1: Mirror, 2: Glass
layout (location = 24) uniform mat4 WorldMatrices[MAX_OBJECT_NUM];

const float zero = 0.0f;
const float one = 1.0f;
const float two_pi = 6.28318530717958647692528676655900576f;
const float one_over_pi = 0.318309886183790671537767526745028724f;

struct IntersectionInfo
{
   int ObjectIndex;
   vec3 Position;
   vec3 Normal;
   vec3 ShadingNormal;
};

float getRandomFloat(inout uint seed)
{
   seed = (seed ^ 61u) ^ (seed >> 16u);
   seed *= 9u;
   seed = seed ^ (seed >> 4u);
   seed *= 0x27d4eb2du;
   seed = seed ^ (seed >> 15u);
   return float(seed) / 4294967296.0f;
}

// this hemisphere is towards the y-axis, and its lower plane is the xz-plane.
vec3 getRandomPointInUnitHemisphere(inout float pdf, inout uint seed)
{
   float phi = two_pi * getRandomFloat( seed ); // [0, 2pi]
   float theta = acos( 2.0f * getRandomFloat( seed ) - one ) * 0.5f; // [0, pi/2]
   float cos_theta = cos( theta );
   pdf *= cos_theta * one_over_pi;
   return vec3(cos( phi ) * sin( theta ), cos_theta, sin( phi ) * sin( theta ));
}

vec3 getSamplePointAroundAxis(inout float pdf, inout uint seed, in vec3 v)
{
   vec3 u = abs( v.y ) < 0.9f ?
      normalize( cross( v, vec3(zero, one, zero) ) ) :
      normalize( cross( v, vec3(zero, zero, one) ) );
   vec3 n = normalize( cross( u, v ) );
   return mat3(u, v, n) * getRandomPointInUnitHemisphere( pdf, seed );
}

vec3 getSampleRayFromLight(inout vec3 ray_origin, inout vec3 ray_direction, inout uint seed)
{
   // Currently, the number of lights is 2.
   const int light_num = 2;
   int light_index = getRandomFloat( seed ) > 0.5f ? 0 : 1;
   vec3 v0 = lights[light_index].Vertex0;
   vec3 v1 = lights[light_index].Vertex1;
   vec3 v2 = lights[light_index].Vertex2;
   float a = getRandomFloat( seed );
   float b = getRandomFloat( seed );
   ray_origin = (one - a - b) * v0 + a * v1 + b * v2;
   vec3 normal = lights[light_index].Normal;
   float pdf = one / (lights[light_index].Area * float(light_num));
   ray_direction = getSamplePointAroundAxis( pdf, seed, normal );
   return lights[light_index].Emission / pdf * abs( dot( ray_direction, normal ) );
}

bool intersectWithBox(in vec3 ray_origin, in vec3 ray_direction, in vec3 min_point, in vec3 max_point)
{
   float exit = one / zero;
   float enter = -one / zero;
   if (abs( ray_direction.x ) > 0.001f) {
      float t_min = (min_point.x - ray_origin.x) / ray_direction.x;
      float t_max = (max_point.x - ray_origin.x) / ray_direction.x;
      float t_enter = min( t_min, t_max );
      float t_exit = max( t_min, t_max );
      if (t_enter > enter) enter = t_enter;
      if (t_exit < exit) exit = t_exit;
      if (enter > exit || exit < zero) return false;
   }
   else if (ray_origin.x < min_point.x || max_point.x < ray_origin.x) return false;

   if (abs( ray_direction.y ) > 0.001f) {
      float t_min = (min_point.y - ray_origin.y) / ray_direction.y;
      float t_max = (max_point.y - ray_origin.y) / ray_direction.y;
      float t_enter = min( t_min, t_max );
      float t_exit = max( t_min, t_max );
      if (t_enter > enter) enter = t_enter;
      if (t_exit < exit) exit = t_exit;
      if (enter > exit || exit < zero) return false;
   }
   else if (ray_origin.y < min_point.y || max_point.y < ray_origin.y) return false;

   if (abs( ray_direction.z ) > 0.001f) {
      float t_min = (min_point.z - ray_origin.z) / ray_direction.z;
      float t_max = (max_point.z - ray_origin.z) / ray_direction.z;
      float t_enter = min( t_min, t_max );
      float t_exit = max( t_min, t_max );
      if (t_enter > enter) enter = t_enter;
      if (t_exit < exit) exit = t_exit;
      if (enter > exit || exit < zero) return false;
   }
   else if (ray_origin.z < min_point.z || max_point.z < ray_origin.z) return false;

   //distance = enter > zero ? enter : exit;
   return true;
}

bool intersectWithTriangle(
   inout vec3 tuv,
   in vec3 ray_origin,
   in vec3 ray_direction,
   in vec3 p0,
   in vec3 p1,
   in vec3 p2
)
{
   vec3 e1 = p1 - p0;
   vec3 e2 = p2 - p0;
   vec3 q = cross( ray_direction, e2 );
   float det = dot( e1, q );
   if (abs( det ) < 1e-5f) return false;

   float f = one / det;
   vec3 s = ray_origin - p0;
   float u = f * dot( s, q );
   if (u < zero) return false;

   vec3 r = cross( s, e1 );
   float v = f * dot( ray_direction, r );
   if (v < zero || u + v > one) return false;

   float t = f * dot( e2, r );
   if (t <= zero) return false;

   tuv = vec3(t, u, v);
   return true;
}

bool findIntersection(inout IntersectionInfo intersection, in vec3 ray_origin, in vec3 ray_direction)
{
   bool intersect = false;
   float distance = one / zero;
   int offset = 0, index_offset = 0;
   for (int i = 0; i < ObjectNum; ++i) {
      mat4 vector_transform = transpose( inverse( WorldMatrices[i] ) );
      if (intersectWithBox( ray_origin, ray_direction, world_bounds[i].MinPoint, world_bounds[i].MaxPoint )) {
         for (int j = 0; j < index_sizes[i]; j += 3) {
            int k0 = 3 * (offset + int(indices[index_offset + j]));
            int k1 = 3 * (offset + int(indices[index_offset + j + 1]));
            int k2 = 3 * (offset + int(indices[index_offset + j + 2]));
            vec3 p0 = vec3(WorldMatrices[i] * vec4(vertices[k0], vertices[k0 + 1], vertices[k0 + 2], one));
            vec3 p1 = vec3(WorldMatrices[i] * vec4(vertices[k1], vertices[k1 + 1], vertices[k1 + 2], one));
            vec3 p2 = vec3(WorldMatrices[i] * vec4(vertices[k2], vertices[k2 + 1], vertices[k2 + 2], one));

            vec3 tuv;
            if (intersectWithTriangle( tuv, ray_origin, ray_direction, p0, p1, p2 )) {
               if (distance > tuv.x) {
                  vec3 n0 = normalize( vec3(vector_transform * vec4(normals[k0], normals[k0 + 1], normals[k0 + 2], zero)) );
                  vec3 n1 = normalize( vec3(vector_transform * vec4(normals[k1], normals[k1 + 1], normals[k1 + 2], zero)) );
                  vec3 n2 = normalize( vec3(vector_transform * vec4(normals[k2], normals[k2 + 1], normals[k2 + 2], zero)) );
                  distance = tuv.x;
                  intersection.ObjectIndex = i;
                  intersection.Normal = (n0 + n1 + n2) / 3.0f;
                  intersection.Position = ray_origin + tuv.x * ray_direction;
                  intersection.ShadingNormal = (one - tuv.y - tuv.z) * n0 + tuv.y * n1 + tuv.z * n2;
                  intersect = true;
               }
            }
         }
      }
      offset += vertex_sizes[i];
      index_offset += index_sizes[i];
   }
   return intersect;
}

float correctShadingNormal(in vec3 wo, in vec3 wi, in vec3 normal, in vec3 shading_normal)
{
   float wo_dot_n = dot( wo, normal );
   float wi_dot_n = dot( wi, normal );
   float wo_dot_sn = dot( wo, shading_normal );
   float wi_dot_sn = dot( wi, shading_normal );
   if (wo_dot_n * wo_dot_sn <= zero || wi_dot_n * wi_dot_sn <= zero) return zero;

   float a = abs( wo_dot_n * wi_dot_sn );
   return a < 1e-5f ? one : abs( wo_dot_sn * wi_dot_n ) / a;
}

vec3 getNextSampleRay(
   inout vec3 ray_origin,
   inout vec3 ray_direction,
   inout uint seed,
   inout IntersectionInfo intersection
)
{
   float pdf = one;
   vec3 incoming = -ray_direction, outgoing, brdf;
   if (ObjectMaterialTypes[intersection.ObjectIndex] == 0) {
      outgoing = getSamplePointAroundAxis( pdf, seed, intersection.ShadingNormal );
      if (dot( incoming, intersection.ShadingNormal ) <= zero) brdf = vec3(zero);
      else brdf = ObjectBRDFs[intersection.ObjectIndex] * one_over_pi;
   }
   else if (ObjectMaterialTypes[intersection.ObjectIndex] == 1) {
      outgoing = reflect( -incoming, intersection.ShadingNormal );
      float d = abs( dot( outgoing, intersection.ShadingNormal ) );
      brdf = d < 1e-5f ? vec3(zero) : ObjectBRDFs[intersection.ObjectIndex] / d;
   }
   else if (ObjectMaterialTypes[intersection.ObjectIndex] == 2) {
      // need to update correctly ...
      outgoing = reflect( -incoming, intersection.ShadingNormal );
      float d = abs( dot( outgoing, intersection.ShadingNormal ) );
      brdf = d < 1e-5f ? vec3(zero) : ObjectBRDFs[intersection.ObjectIndex] / d;
   }

   ray_origin = intersection.Position;
   ray_direction = normalize( outgoing );
   return brdf * correctShadingNormal( outgoing, incoming, intersection.Normal, intersection.ShadingNormal ) / pdf;
}

void main()
{
   int generated_num = 0;
   int step = int(gl_WorkGroupSize.x * gl_NumWorkGroups.x);
   int photons_to_generate = (MaxGlobalPhotonNum + step - 1) / step;
   int index = int(gl_GlobalInvocationID.x) * photons_to_generate;
   uint seed = (gl_GlobalInvocationID.x * 1973u + Seed * 9277u) | 1u;
   while (index < MaxGlobalPhotonNum) {
      vec3 ray_origin, ray_direction;
      vec3 power = getSampleRayFromLight( ray_origin, ray_direction, seed );
      for (int i = 0; i < MaxDepth; ++i) {
         if (any( lessThan( power, vec3(zero) ) )) break;

         IntersectionInfo intersection;
         intersection.ObjectIndex = -1;
         intersection.Position = intersection.Normal = intersection.ShadingNormal = vec3(zero);
         if (!findIntersection( intersection, ray_origin, ray_direction )) break;

         if (ObjectMaterialTypes[intersection.ObjectIndex] == 0) {
            photons[index + generated_num].Power = power;
            photons[index + generated_num].Position = intersection.Position;
            photons[index + generated_num].IncomingDirection = -ray_direction;
            generated_num++;
            if (generated_num == photons_to_generate || index + generated_num >= MaxGlobalPhotonNum) return;
         }

         if (i > 0) {
            float russian_roulette = min( max( power.x, max( power.y, power.z ) ), one );
            if (getRandomFloat( seed ) < russian_roulette) power /= russian_roulette;
            else break;
         }

         power *= getNextSampleRay( ray_origin, ray_direction, seed, intersection );
      }
   }
}